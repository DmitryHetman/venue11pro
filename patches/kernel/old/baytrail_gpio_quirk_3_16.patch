diff --git a/drivers/mmc/host/sdhci-acpi.c b/drivers/mmc/host/sdhci-acpi.c
index ebb3f39..ebed2a0 100644
--- a/drivers/mmc/host/sdhci-acpi.c
+++ b/drivers/mmc/host/sdhci-acpi.c
@@ -123,7 +123,7 @@ static const struct sdhci_acpi_slot sdhci_acpi_slot_int_emmc = {
 
 static const struct sdhci_acpi_slot sdhci_acpi_slot_int_sdio = {
 	.quirks  = SDHCI_QUIRK_BROKEN_CARD_DETECTION,
-	.quirks2 = SDHCI_QUIRK2_HOST_OFF_CARD_ON,
+	.quirks2 = SDHCI_QUIRK2_HOST_OFF_CARD_ON | SDHCI_QUIRK2_BROKEN_POWER_ENABLE,
 	.caps    = MMC_CAP_NONREMOVABLE | MMC_CAP_POWER_OFF_CARD,
 	.flags   = SDHCI_ACPI_RUNTIME_PM,
 	.pm_caps = MMC_PM_KEEP_POWER,
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 9a79fc4..7a06008 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -22,6 +22,7 @@
 #include <linux/scatterlist.h>
 #include <linux/regulator/consumer.h>
 #include <linux/pm_runtime.h>
+#include <linux/gpio.h>
 
 #include <linux/leds.h>
 
@@ -1221,6 +1221,10 @@
 }
 EXPORT_SYMBOL_GPL(sdhci_set_clock);
 
+static inline void sdhci_set_power_quirk(unsigned short power) {
+	gpio_set_value(SDHCI_POWER_QUIRK_GPIO, power);
+}
+
 static void sdhci_set_power(struct sdhci_host *host, unsigned char mode,
                            unsigned short vdd)
 {
@@ -1253,6 +1257,9 @@
		sdhci_writeb(host, 0, SDHCI_POWER_CONTROL);
		if (host->quirks2 & SDHCI_QUIRK2_CARD_ON_NEEDS_BUS_ON)
			sdhci_runtime_pm_bus_off(host);
+               /* The intel Bay Trail SoCs need to assert a GPIO as a work around */
+               if (host->quirks2 & SDHCI_QUIRK2_BROKEN_POWER_ENABLE)
+                       sdhci_set_power_quirk(0);
		vdd = 0;
	} else {
		/*
@@ -1277,6 +1284,10 @@
		if (host->quirks2 & SDHCI_QUIRK2_CARD_ON_NEEDS_BUS_ON)
			sdhci_runtime_pm_bus_on(host);
 
+               /* The intel Bay Trail SoCs need to assert a GPIO as a work around */
+               if (host->quirks2 & SDHCI_QUIRK2_BROKEN_POWER_ENABLE)
+                       sdhci_set_power_quirk(1);
+
		/*
		 * Some controllers need an extra 10ms delay of 10ms before
		 * they can apply clock after applying power
@@ -2820,6 +2834,18 @@ int sdhci_add_host(struct sdhci_host *host)
 		host->flags &= ~SDHCI_USE_SDMA;
 	}
 
+    if ((host->quirks2 & SDHCI_QUIRK2_BROKEN_POWER_ENABLE)) {
+        printk("Using GPIO for power enable as it is marked broken\n");
+        if (gpio_request(SDHCI_POWER_QUIRK_GPIO, "SDIO_PWR_EN") < 0) {
+            printk("Unable to request GPIO. SDIO may be broken.");
+			host->quirks2 = host->quirks2 & ~SDHCI_QUIRK2_BROKEN_POWER_ENABLE;
+        }
+        else if (gpio_direction_output(SDHCI_POWER_QUIRK_GPIO, 0) < 0) {
+            printk("Unable to set GPIO direction. SDIO may be broken.");
+			host->quirks2 = host->quirks2 & ~SDHCI_QUIRK2_BROKEN_POWER_ENABLE;
+        }
+    }
+
 	if ((host->version >= SDHCI_SPEC_200) &&
 		(caps[0] & SDHCI_CAN_DO_ADMA2))
 		host->flags |= SDHCI_USE_ADMA;
@@ -3325,6 +3351,10 @@ void sdhci_remove_host(struct sdhci_host *host, int dead)
 	tasklet_kill(&host->card_tasklet);
 	tasklet_kill(&host->finish_tasklet);
 
+    if (host->quirks2 & SDHCI_QUIRK2_BROKEN_POWER_ENABLE) {
+        gpio_free(SDHCI_POWER_QUIRK_GPIO);
+    }
+
 	if (host->vmmc) {
 		regulator_disable(host->vmmc);
 		regulator_put(host->vmmc);
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index 0a3ed01..027fcd1 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -84,11 +84,12 @@
 #define   SDHCI_CTRL_ADMA64	0x18
 #define   SDHCI_CTRL_8BITBUS	0x20
 
-#define SDHCI_POWER_CONTROL	0x29
-#define  SDHCI_POWER_ON		0x01
-#define  SDHCI_POWER_180	0x0A
-#define  SDHCI_POWER_300	0x0C
-#define  SDHCI_POWER_330	0x0E
+#define SDHCI_POWER_CONTROL		0x29
+#define  SDHCI_POWER_ON			0x01
+#define  SDHCI_POWER_180		0x0A
+#define  SDHCI_POWER_300		0x0C
+#define  SDHCI_POWER_330		0x0E
+#define SDHCI_POWER_QUIRK_GPIO 195 /*GPIO offset 41 of SCORE device is SD3_PWR_EN*/
 
 #define SDHCI_BLOCK_GAP_CONTROL	0x2A
 
diff --git a/drivers/pinctrl/pinctrl-baytrail.c b/drivers/pinctrl/pinctrl-baytrail.c
index 6e8301f..6c8eda2 100644
--- a/drivers/pinctrl/pinctrl-baytrail.c
+++ b/drivers/pinctrl/pinctrl-baytrail.c
@@ -151,9 +151,9 @@ static void __iomem *byt_gpio_reg(struct gpio_chip *chip, unsigned offset,
 
 static bool is_special_pin(struct byt_gpio *vg, unsigned offset)
 {
-	/* SCORE pin 92-93 */
+	/* SCORE pin 92-93; 41 for SDIO pwr_en bug  */
 	if (!strcmp(vg->range->name, BYT_SCORE_ACPI_UID) &&
-		offset >= 92 && offset <= 93)
+	   ((offset >= 92 && offset <= 93) || (offset == 41)))
 		return true;
 
 	/* SUS pin 11-21 */
@@ -176,6 +176,10 @@ static int byt_gpio_request(struct gpio_chip *chip, unsigned offset)
 	 * But, some pins may have func pin mux 001 represents
 	 * GPIO function. Only allow user to export pin with
 	 * func pin mux preset as GPIO function by BIOS/FW.
+	 *
+	 * We do make an exception, however, for pin 41 which
+	 * is needed in order to power up the SDIO bus (as per
+	 * the intel erratum)
 	 */
 	value = readl(reg) & BYT_PIN_MUX;
 	special = is_special_pin(vg, offset);
@@ -185,6 +189,13 @@ static int byt_gpio_request(struct gpio_chip *chip, unsigned offset)
 		return -EINVAL;
 	}
 
+	/* This is an attempt to stop the SDHCI drivers from requesting IRQ lines
+	 * through the pinctrl driver. This may be a quirk in the hardware or it
+	 * may be a bug here in the IRQ handling
+	 */
+	if (offset == 38)
+		return -EINVAL;
+
 	pm_runtime_get(&vg->pdev->dev);
 
 	return 0;
diff --git a/include/linux/mmc/sdhci.h b/include/linux/mmc/sdhci.h
index 7be12b8..3a7fd87 100644
--- a/include/linux/mmc/sdhci.h
+++ b/include/linux/mmc/sdhci.h
@@ -102,6 +102,8 @@ struct sdhci_host {
 #define SDHCI_QUIRK2_BROKEN_HS200			(1<<6)
 /* Controller does not support DDR50 */
 #define SDHCI_QUIRK2_BROKEN_DDR50			(1<<7)
+/* Controller cannot initialize power (must use GPIO instead) */
+#define SDHCI_QUIRK2_BROKEN_POWER_ENABLE		(1<<8)
 
 	int irq;		/* Device IRQ */
 	void __iomem *ioaddr;	/* Mapped address */
