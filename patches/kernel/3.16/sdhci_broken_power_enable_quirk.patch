Signed-off-by: Jon Pry <jonpry <at> gmail.com>
---
diff --git a/drivers/mmc/host/sdhci-acpi.c b/drivers/mmc/host/sdhci-acpi.c
index ebb3f39..ebed2a0 100644
--- a/drivers/mmc/host/sdhci-acpi.c
+++ b/drivers/mmc/host/sdhci-acpi.c
 <at>  <at>  -123,7 +123,7  <at>  <at>  static const struct sdhci_acpi_slot sdhci_acpi_slot_int_emmc = {

 static const struct sdhci_acpi_slot sdhci_acpi_slot_int_sdio = {
 	.quirks  = SDHCI_QUIRK_BROKEN_CARD_DETECTION,
-	.quirks2 = SDHCI_QUIRK2_HOST_OFF_CARD_ON,
+	.quirks2 = SDHCI_QUIRK2_HOST_OFF_CARD_ON | SDHCI_QUIRK2_BROKEN_POWER_ENABLE,
 	.caps    = MMC_CAP_NONREMOVABLE | MMC_CAP_POWER_OFF_CARD,
 	.flags   = SDHCI_ACPI_RUNTIME_PM,
 	.pm_caps = MMC_PM_KEEP_POWER,
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 9a79fc4..5a0e928 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
 <at>  <at>  -22,6 +22,7  <at>  <at> 
 #include <linux/scatterlist.h>
 #include <linux/regulator/consumer.h>
 #include <linux/pm_runtime.h>
+#include <linux/gpio.h>

 #include <linux/leds.h>

 <at>  <at>  -1261,6 +1262,10  <at>  <at>  static inline void sdhci_update_clock(struct sdhci_host *host)
 	sdhci_set_clock(host, clock);
 }

+static inline void sdhci_set_power_quirk(unsigned short power) {
+	gpio_set_value(SDHCI_POWER_QUIRK_GPIO, power);
+}
+
 static int sdhci_set_power(struct sdhci_host *host, unsigned short power)
 {
 	u8 pwr = 0;
 <at>  <at>  -1292,6 +1297,9  <at>  <at>  static int sdhci_set_power(struct sdhci_host *host, unsigned short power)
 		sdhci_writeb(host, 0, SDHCI_POWER_CONTROL);
 		if (host->quirks2 & SDHCI_QUIRK2_CARD_ON_NEEDS_BUS_ON)
 			sdhci_runtime_pm_bus_off(host);
+		/* The intel Bay Trail SoCs need to assert a GPIO as a work around */
+		if (host->quirks2 & SDHCI_QUIRK2_BROKEN_POWER_ENABLE)
+			sdhci_set_power_quirk(0);
 		return 0;
 	}

 <at>  <at>  -1311,8 +1319,14  <at>  <at>  static int sdhci_set_power(struct sdhci_host *host, unsigned short power)

 	pwr |= SDHCI_POWER_ON;

+
 	sdhci_writeb(host, pwr, SDHCI_POWER_CONTROL);

+	/* The intel Bay Trail SoCs need to assert a GPIO as a work around */
+	if (host->quirks2 & SDHCI_QUIRK2_BROKEN_POWER_ENABLE)
+		sdhci_set_power_quirk(1);
+
+
 	if (host->quirks2 & SDHCI_QUIRK2_CARD_ON_NEEDS_BUS_ON)
 		sdhci_runtime_pm_bus_on(host);

 <at>  <at>  -2820,6 +2841,18  <at>  <at>  int sdhci_add_host(struct sdhci_host *host)
 		host->flags &= ~SDHCI_USE_SDMA;
 	}

+    if ((host->quirks2 & SDHCI_QUIRK2_BROKEN_POWER_ENABLE)) {
+        printk("Using GPIO for power enable as it is marked broken\n");
+        if (gpio_request(SDHCI_POWER_QUIRK_GPIO, "SDIO_PWR_EN") < 0) {
+            printk("Unable to request GPIO. SDIO may be broken.");
+			host->quirks2 = host->quirks2 & ~SDHCI_QUIRK2_BROKEN_POWER_ENABLE;
+        }
+        else if (gpio_direction_output(SDHCI_POWER_QUIRK_GPIO, 0) < 0) {
+            printk("Unable to set GPIO direction. SDIO may be broken.");
+			host->quirks2 = host->quirks2 & ~SDHCI_QUIRK2_BROKEN_POWER_ENABLE;
+        }
+    }
+
 	if ((host->version >= SDHCI_SPEC_200) &&
 		(caps[0] & SDHCI_CAN_DO_ADMA2))
 		host->flags |= SDHCI_USE_ADMA;
 <at>  <at>  -3325,6 +3358,10  <at>  <at>  void sdhci_remove_host(struct sdhci_host *host, int dead)
 	tasklet_kill(&host->card_tasklet);
 	tasklet_kill(&host->finish_tasklet);

+    if (host->quirks2 & SDHCI_QUIRK2_BROKEN_POWER_ENABLE) {
+        gpio_free(SDHCI_POWER_QUIRK_GPIO);
+    }
+
 	if (host->vmmc) {
 		regulator_disable(host->vmmc);
 		regulator_put(host->vmmc);
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index 0a3ed01..027fcd1 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
 <at>  <at>  -84,11 +84,12  <at>  <at> 
 #define   SDHCI_CTRL_ADMA64	0x18
 #define   SDHCI_CTRL_8BITBUS	0x20

 #define SDHCI_POWER_CONTROL	0x29
 #define  SDHCI_POWER_ON		0x01
 #define  SDHCI_POWER_180	0x0A
 #define  SDHCI_POWER_300	0x0C
 #define  SDHCI_POWER_330	0x0E
+#define SDHCI_POWER_QUIRK_GPIO 195 /*GPIO offset 41 of SCORE device is SD3_PWR_EN*/

 #define SDHCI_BLOCK_GAP_CONTROL	0x2A

diff --git a/include/linux/mmc/sdhci.h b/include/linux/mmc/sdhci.h
index 7be12b8..92cec16 100644
--- a/include/linux/mmc/sdhci.h
+++ b/include/linux/mmc/sdhci.h
 <at>  <at>  -102,6 +102,9  <at>  <at>  struct sdhci_host {
 #define SDHCI_QUIRK2_BROKEN_HS200			(1<<6)
 /* Controller does not support DDR50 */
 #define SDHCI_QUIRK2_BROKEN_DDR50			(1<<7)
+/* Controller cannot initialize power (must use GPIO instead) */
+#define SDHCI_QUIRK2_BROKEN_POWER_ENABLE		(1<<8)
+

 	int irq;		/* Device IRQ */
 	void __iomem *ioaddr;	/* Mapped address */
--
