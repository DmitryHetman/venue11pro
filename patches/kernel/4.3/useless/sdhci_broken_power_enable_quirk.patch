diff --git a/drivers/mmc/host/sdhci-acpi.c b/drivers/mmc/host/sdhci-acpi.c
index 22d929f..1c5cd58 100644
--- a/drivers/mmc/host/sdhci-acpi.c
+++ b/drivers/mmc/host/sdhci-acpi.c
@@ -214,7 +214,7 @@ static const struct sdhci_acpi_slot sdhci_acpi_slot_int_emmc = {
 static const struct sdhci_acpi_slot sdhci_acpi_slot_int_sdio = {
 	.quirks  = SDHCI_QUIRK_BROKEN_CARD_DETECTION |
 		   SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,
-	.quirks2 = SDHCI_QUIRK2_HOST_OFF_CARD_ON,
+	.quirks2 = SDHCI_QUIRK2_HOST_OFF_CARD_ON | SDHCI_QUIRK2_BROKEN_POWER_ENABLE,
 	.caps    = MMC_CAP_NONREMOVABLE | MMC_CAP_POWER_OFF_CARD |
 		   MMC_CAP_BUS_WIDTH_TEST | MMC_CAP_WAIT_WHILE_BUSY,
 	.flags   = SDHCI_ACPI_RUNTIME_PM,
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 64b7fdb..ccd98f1 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -22,6 +22,7 @@
 #include <linux/scatterlist.h>
 #include <linux/regulator/consumer.h>
 #include <linux/pm_runtime.h>
+#include <linux/gpio.h>
 
 #include <linux/leds.h>
 
@@ -1266,6 +1267,10 @@ clock_set:
 }
 EXPORT_SYMBOL_GPL(sdhci_set_clock);
 
+static inline void sdhci_set_power_quirk(unsigned short power) {
+	gpio_set_value(SDHCI_POWER_QUIRK_GPIO, power);
+}
+
 static void sdhci_set_power(struct sdhci_host *host, unsigned char mode,
 			    unsigned short vdd)
 {
@@ -1312,6 +1317,8 @@ static void sdhci_set_power(struct sdhci_host *host, unsigned char mode,
 		sdhci_writeb(host, 0, SDHCI_POWER_CONTROL);
 		if (host->quirks2 & SDHCI_QUIRK2_CARD_ON_NEEDS_BUS_ON)
 			sdhci_runtime_pm_bus_off(host);
+		if (host->quirks2 & SDHCI_QUIRK2_BROKEN_POWER_ENABLE)
+			sdhci_set_power_quirk(0);
 		vdd = 0;
 	} else {
 		/*
@@ -1333,6 +1340,10 @@ static void sdhci_set_power(struct sdhci_host *host, unsigned char mode,
 
 		sdhci_writeb(host, pwr, SDHCI_POWER_CONTROL);
 
+		/* The intel Bay Trail SoCs need to assert a GPIO as a work around */
+		if (host->quirks2 & SDHCI_QUIRK2_BROKEN_POWER_ENABLE)
+			sdhci_set_power_quirk(1);
+
 		if (host->quirks2 & SDHCI_QUIRK2_CARD_ON_NEEDS_BUS_ON)
 			sdhci_runtime_pm_bus_on(host);
 
@@ -2919,6 +2930,18 @@ int sdhci_add_host(struct sdhci_host *host)
 		host->flags &= ~SDHCI_USE_SDMA;
 	}
 
+	if ((host->quirks2 & SDHCI_QUIRK2_BROKEN_POWER_ENABLE)) {
+		printk("Using GPIO for power enable as it is marked broken\n");
+		if (gpio_request(SDHCI_POWER_QUIRK_GPIO, "SDIO_PWR_EN") < 0) {
+			printk("Unable to request GPIO. SDIO may be broken.");
+			host->quirks2 = host->quirks2 & ~SDHCI_QUIRK2_BROKEN_POWER_ENABLE;
+		}
+		else if (gpio_direction_output(SDHCI_POWER_QUIRK_GPIO, 0) < 0) {
+			printk("Unable to set GPIO direction. SDIO may be broken.");
+			host->quirks2 = host->quirks2 & ~SDHCI_QUIRK2_BROKEN_POWER_ENABLE;
+		}
+	}
+
 	if ((host->version >= SDHCI_SPEC_200) &&
 		(caps[0] & SDHCI_CAN_DO_ADMA2))
 		host->flags |= SDHCI_USE_ADMA;
@@ -3462,6 +3485,10 @@ void sdhci_remove_host(struct sdhci_host *host, int dead)
 
 	tasklet_kill(&host->finish_tasklet);
 
+	if (host->quirks2 & SDHCI_QUIRK2_BROKEN_POWER_ENABLE) {
+		gpio_free(SDHCI_POWER_QUIRK_GPIO);
+	}
+
 	if (!IS_ERR(mmc->supply.vqmmc))
 		regulator_disable(mmc->supply.vqmmc);
 
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index 7c02ff4..3c8ee2e 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -91,6 +91,8 @@
 #define  SDHCI_POWER_300	0x0C
 #define  SDHCI_POWER_330	0x0E
 
+#define SDHCI_POWER_QUIRK_GPIO 195 /*GPIO offset 41 of SCORE device is SD3_PWR_EN*/
+
 #define SDHCI_BLOCK_GAP_CONTROL	0x2A
 
 #define SDHCI_WAKE_UP_CONTROL	0x2B
@@ -412,6 +414,8 @@ struct sdhci_host {
 #define SDHCI_QUIRK2_ACMD23_BROKEN			(1<<14)
 /* Broken Clock divider zero in controller */
 #define SDHCI_QUIRK2_CLOCK_DIV_ZERO_BROKEN		(1<<15)
+/* Controller cannot initialize power (must use GPIO instead) */
+#define SDHCI_QUIRK2_BROKEN_POWER_ENABLE		(1<<31)
 
 	int irq;		/* Device IRQ */
 	void __iomem *ioaddr;	/* Mapped address */
